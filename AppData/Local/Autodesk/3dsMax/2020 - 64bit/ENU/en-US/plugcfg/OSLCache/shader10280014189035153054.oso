OpenShadingLanguage 1.00
# Compiled by oslc 1.10.2
# options: -IC:/Program Files/Autodesk/3ds Max 2020/OSL/
shader Float1of5	%meta{string,help,"Pick one of 5 inputs"} %meta{string,label,"1 of 5 (float)"} %meta{string,category,"Switchers"} 
param	int	Index	0		%meta{string,help,"Pick the index (number) of the input to use. "}  %read{0,0} %write{2147483647,-1}
param	float	I0	0		%meta{string,label,"Input 0"}  %read{13,13} %write{2147483647,-1}
param	float	I1	0		%meta{string,label,"Input 1"}  %read{16,16} %write{2147483647,-1}
param	float	I2	0		%meta{string,label,"Input 2"}  %read{19,19} %write{2147483647,-1}
param	float	I3	0		%meta{string,label,"Input 3"}  %read{22,22} %write{2147483647,-1}
param	float	I4	0		%meta{string,label,"Input 4"}  %read{25,25} %write{2147483647,-1}
param	int	StartIdx	0		%meta{string,label,"Start Index"} %meta{string,help,"Offsets the input index so that this number will map to the first input. E.g. if set to 10, the first input (labeled Input 0) will map to index 10, rather than 0. This is used when cascading multiple switchers into each other and allows them to cover different ranges."}  %read{0,0} %write{2147483647,-1}
param	int	Mod	0		%meta{string,label,"Range: Number of inputs"} %meta{string,help,"If 0, returns all outputs and any outside the range uses the 'Outside Range' input. If a nonzero number, only uses that many inputs, repeated in a rotating fashion."}  %read{1,2} %write{2147483647,-1}
param	float	Outside	0		%meta{string,label,"Outside Range"} %meta{string,help,"The value to return when the index falls outside the set of available inputs. This can be used to connect a second switcher to support a larger number of inputs. "}  %read{10,26} %write{2147483647,-1}
oparam	float	Out	0		%read{2147483647,-1} %write{10,26}
local	int	idx	%read{2,23} %write{0,2}
const	int	$const1	0		%read{3,11} %write{2147483647,-1}
temp	int	$tmp1	%read{4,4} %write{3,3}
temp	int	$tmp2	%read{5,9} %write{4,8}
const	int	$const2	4		%read{6,23} %write{2147483647,-1}
temp	int	$tmp3	%read{7,7} %write{6,6}
temp	int	$tmp4	%read{8,8} %write{7,7}
temp	int	$tmp5	%read{12,12} %write{11,11}
const	int	$const3	1		%read{14,14} %write{2147483647,-1}
temp	int	$tmp6	%read{15,15} %write{14,14}
const	int	$const4	2		%read{17,17} %write{2147483647,-1}
temp	int	$tmp7	%read{18,18} %write{17,17}
const	int	$const5	3		%read{20,20} %write{2147483647,-1}
temp	int	$tmp8	%read{21,21} %write{20,20}
temp	int	$tmp9	%read{24,24} %write{23,23}
code ___main___
# OSL\Float1of5.osl:40
# 	
	sub		idx Index StartIdx 	%filename{"OSL\Float1of5.osl"} %line{40} %argrw{"wrr"}
# OSL\Float1of5.osl:42
# 		idx = idx % Mod;
	if		Mod 3 3 	%line{42} %argrw{"r"}
# OSL\Float1of5.osl:43
# 
	mod		idx idx Mod 	%line{43} %argrw{"wrr"}
# OSL\Float1of5.osl:45
# 	{
	lt		$tmp1 idx $const1 	%line{45} %argrw{"wrr"}
	neq		$tmp2 $tmp1 $const1 	%argrw{"wrr"}
	if		$tmp2 6 9 	%argrw{"r"}
	gt		$tmp3 idx $const2 	%argrw{"wrr"}
	neq		$tmp4 $tmp3 $const1 	%argrw{"wrr"}
	assign		$tmp2 $tmp4 	%argrw{"wr"}
	if		$tmp2 11 27 	%argrw{"r"}
# OSL\Float1of5.osl:47
# 	}
	assign		Out Outside 	%line{47} %argrw{"wr"}
# OSL\Float1of5.osl:52
# 		OUT(1)
	eq		$tmp5 idx $const1 	%line{52} %argrw{"wrr"}
	if		$tmp5 14 27 	%argrw{"r"}
	assign		Out I0 	%argrw{"wr"}
# OSL\Float1of5.osl:53
# 		OUT(2)
	eq		$tmp6 idx $const3 	%line{53} %argrw{"wrr"}
	if		$tmp6 17 27 	%argrw{"r"}
	assign		Out I1 	%argrw{"wr"}
# OSL\Float1of5.osl:54
# 		OUT(3)
	eq		$tmp7 idx $const4 	%line{54} %argrw{"wrr"}
	if		$tmp7 20 27 	%argrw{"r"}
	assign		Out I2 	%argrw{"wr"}
# OSL\Float1of5.osl:55
# 		OUT(4)
	eq		$tmp8 idx $const5 	%line{55} %argrw{"wrr"}
	if		$tmp8 23 27 	%argrw{"r"}
	assign		Out I3 	%argrw{"wr"}
# OSL\Float1of5.osl:56
# 		Out = Outside;
	eq		$tmp9 idx $const2 	%line{56} %argrw{"wrr"}
	if		$tmp9 26 27 	%argrw{"r"}
	assign		Out I4 	%argrw{"wr"}
# OSL\Float1of5.osl:57
# #undef OUT
	assign		Out Outside 	%line{57} %argrw{"wr"}
	end
